API - набор уже готовых функций и свойств, которые мы можем использовать. (dom api, bluetooth api, jsonplaceholder)

1) Как мы выполняем операцию: запустить скрипт, отправить запрос (в vscode мы не может использовать querySelector и тп)
2) Что мы даем API - данные (для регистрации, пароли)
3) результат (ответ): активация сторонней функции, получение данных

https://habr.com/ru/post/464261/



Жизненный цикл компонентов: 
1) конструктор
2) render
3) mount
4) update
5) unmount (удаление)

хукки жизненного цикла - componentDidMount(), componentDidUpdate(), componentWillUnmount()
мы их можем использовать для обновлени компонентов

в конструкторе нельзя делать обращения к серверам, тк наш компонент на этапе конструктора еще не создан, поэтому отправляет запрос 2 раза для корректной работы
(некуда еще засунуть полученные данные)

componentDidMount() - прекрасное место для вызова сетевых функций и назначать инициализацию компонента

если на компонент идет таймер вызова функции, то ставить его надо в componentDidMount(), а очищать (clearInterval) в componentWillUnmount(), если он удаляется, чтобы не было утечки памяти
то же самое для addEventListener и removeEventListener







Предохранители.

При возникновении ошибки у нас падает все приложение. Как сделать так, чтобы падал только тот компонент, где была произведена ошибка?
Раньше можно было использовать componentDidCatch, где есть два аргумента - err и info
Теперь компонент не крашит полностью приложение, в консоль что-то выводится.
Но в новых версиях реакта этот компонент переделали и при ошибке все равно падает все приложение.

Предохранители - классовые компоненты, которые оборачивают другие компоненты и если там произошла ошибка, то предохранители ее ловят.
Внедрение их становится чуть ли не обязательным.





Установить proptypes (проверка типов) - npm i prop-types
Можно прописывать правила для проверки пропсов. типы пропсов. если не подходит по типам, то показываем уведомление в терминале.
работает только для режима разработки



props.children.
есть компонент (обертка), но мы не знаем, что может быть внутри неё
хотим поместить что угодно, пример:

const DynamicComp = (props) => {
   return (
      <div className={props.color}>
         {props.children} - указание
      </div>
   )
}

применение: 
<DynamicComp>
   <h2>dsakdjakla</h2>
   <h2>dsakdjakla</h2>
</DynamicComp>

в данном случае h2 передаются в props.children

так же работает ErrorBoundary. там указано this.props.children, тк внутрь этого компонента может быть помещен любой наш компонент

//есть методы и свойства, например, map, forEach
const DynamicComp = (props) => {
   return (
      <div className={props.color}>
         {  //импортировать react
            React.Children.map(props.children, child => {
               //но мы не должны мутировать то, что будет написано в props.children напрямую (иммутабельность)
               return React.cloneElement(child, {className: 'shadow'...}) - второе - то, что добавляем к элемент
            })
         }
      </div>
   )
}


в пропсы компонентам можно передавать компоненты, тот же DynamicComp


ref - см app_test